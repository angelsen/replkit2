# ReplKit2 + TextKit + FastMCP Guide

Build stateful REPL apps with rich ASCII output and MCP integration.

## Basic App Structure

```python
from replkit2 import App
from dataclasses import dataclass, field

@dataclass
class AppState:
    items: list[dict] = field(default_factory=list)
    counter: int = 0

app = App("myapp", AppState)
```

## Commands with Display Types

```python
# Table display
@app.command(display="table", headers=["ID", "Name", "Status"])
def list_items(state):
    return [{"ID": i, "Name": item["name"], "Status": item["status"]} 
            for i, item in enumerate(state.items)]

# Box display
@app.command(display="box", title="Summary")
def status(state):
    return f"Total items: {len(state.items)}\nLast update: {state.counter}"

# Tree display
@app.command(display="tree")
def hierarchy(state):
    return {
        "active": [i for i in state.items if i["status"] == "active"],
        "pending": [i for i in state.items if i["status"] == "pending"]
    }

# Progress display
@app.command(display="progress", show_percentage=True)
def completion(state):
    done = sum(1 for i in state.items if i["status"] == "done")
    return {"value": done, "total": len(state.items)}
```

## FastMCP Integration

```python
from replkit2 import App, FastMCPTool, FastMCPResource

# App with MCP configuration
app = App("notes", 
    NotesState,
    uri_scheme="notes",  # URIs like notes://command
    fastmcp={"tags": {"productivity"}}  # Default tags
)

# MCP Tool
@app.command(fastmcp={"type": "tool"})
def add_note(state, text: str, priority: str = "normal"):
    """Add a new note."""
    note = {"id": state.next_id, "text": text, "priority": priority}
    state.notes.append(note)
    state.next_id += 1
    return f"Added note #{note['id']}"

# MCP Resource (simple URI)
@app.command(fastmcp={"type": "resource", "mime_type": "application/json"})
def summary(state):
    """Get notes summary."""
    return {"total": len(state.notes), "next_id": state.next_id}

# MCP Resource (URI template auto-generated: notes://get_note/{id})
@app.command(fastmcp={"type": "resource"})
def get_note(state, id: int):
    """Get note by ID."""
    return next((n for n in state.notes if n["id"] == id), None)

# MCP Prompt
@app.command(fastmcp={"type": "prompt"})
def brainstorm(state, topic: str = None):
    """Generate brainstorming prompt."""
    context = "\n".join(n["text"] for n in state.notes[-5:])
    return f"Based on: {topic or 'recent notes'}\n{context}\nSuggest 3 ideas:"

# Not exposed to MCP
@app.command(fastmcp={"enabled": False})
def debug(state):
    return vars(state)
```

## Running the App

```python
if __name__ == "__main__":
    import sys
    if "--mcp" in sys.argv:
        app.mcp.run()  # MCP server mode
    else:
        app.run(title="My App")  # REPL mode
```

## Type-Safe MCP Config

```python
# Full IDE support with typed configs
@app.command(
    display="table",
    fastmcp={
        "type": "tool",
        "tags": {"write", "important"},
        "description": "Override the docstring"
    }
)
def important_action(state, data: str):
    """This docstring is overridden by fastmcp.description."""
    return process(data)
```

## Custom Display Components

```python
# Register custom display type
@app.serializer.register("dashboard")
def dashboard_display(data, meta):
    from replkit2.textkit import compose, box, table
    return compose(
        box(data["summary"], title="Overview"),
        table(data["items"], headers=["ID", "Status"]),
        spacing=1
    )

# Use custom display
@app.command(display="dashboard")
def dashboard(state):
    return {
        "summary": f"Active: {len(state.items)}",
        "items": [{"ID": i, "Status": item["status"]} 
                  for i, item in enumerate(state.items)]
    }
```

## Key Patterns

1. **State**: First parameter of every command
2. **Display**: Return data matching display type (list of dicts for tables)
3. **FastMCP**: Dict with "type" field minimum, inherits app defaults
4. **URIs**: Auto-generated from function signature and parameters
5. **Dual Mode**: Same app works as REPL and MCP server

## Display Type Reference

- `table`: List of dicts → formatted table
- `box`: Any data → bordered box
- `tree`: Nested dict → hierarchical view
- `list`: List → bullet list
- `bar_chart`: Dict with numbers → horizontal bars
- `progress`: {"value": n, "total": m} → progress bar

## FastMCP Type Reference

- `{"type": "tool"}`: Callable actions
- `{"type": "resource"}`: Readable data (GET-like)
- `{"type": "prompt"}`: Prompt templates
- `{"enabled": False}`: Exclude from MCP
- `{"uri": "custom://path"}`: Override auto-generated URI
- `{"stub": True}`: Generate stub resource for template URIs
- `{"stub": {"response": {...}}}`: Custom stub response

## Stub Resources for MCP Clients

Some MCP clients don't support resource templates. Use stubs to provide examples:

```python
# Basic stub - shows template and description
@app.command(fastmcp={"type": "resource", "stub": True})
def get_note(state, id: int):
    """Get note by ID."""
    return state.notes[id]
# Creates: notes://get_note/{id} (template)
# Creates: notes://get_note/:id (stub showing usage)

# Custom stub response
@app.command(fastmcp={
    "type": "resource",
    "stub": {
        "response": {
            "example": "notes://get_note/123",
            "usage": "Use list_notes to find IDs",
            "hint": "IDs are integers from 1-1000"
        }
    }
})
def get_note(state, id: int):
    """Get note by ID."""
    return state.notes[id]

# Disable stub for specific resource
@app.command(fastmcp={"type": "resource", "stub": False})
def search(state, query: str):
    """Search notes."""
    return results
```

Stubs appear as regular resources with `:param` syntax and return help info when called.