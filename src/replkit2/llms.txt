# ReplKit2 Guide for LLMs

This guide helps LLMs write effective ReplKit2 applications following Claude 4 best practices.

## Core Principles

### Be Explicit with Display Requirements
Instead of: "Show todos"
Use: "@command(display='table', headers=['id', 'task', 'status'])"

### Provide Context for Design Decisions
Instead of: "Add a command"
Use: "Add a command that returns structured data for table display, enabling users to see all fields at once"

## Writing Effective Commands

### 1. State Management
```python
from dataclasses import dataclass, field
from replkit2 import App

@dataclass
class TodoState:
    todos: list[dict] = field(default_factory=list)  # Be explicit with type annotations
    next_id: int = 1

# Create app with state
app = App("todo", TodoState)
```

### 2. Display Hints
Always specify display intent with Flask-style decorators:
```python
@app.command(display="table", headers=["id", "task", "done"])
def list_todos(state):
    return state.todos

@app.command(display="box", title="Summary", width=60)
def summary(state):
    return f"Total: {len(state.todos)} tasks"

@app.command(display="bar_chart", show_values=True)
def priority_chart(state):
    return {"high": 5, "medium": 3, "low": 2}
```

### 3. Return Structured Data
Match data structure to display type:
- table: List of dicts with consistent keys
- tree: Nested dict structure
- bar_chart: Dict with numeric values
- list: List of strings

## Best Practices

### Leverage Multiple Serializers
```python
from replkit2 import App, JSONSerializer, TextSerializer

# Create once, use many ways
app = App("myapp", MyState)
json_api = app.using(JSONSerializer())
text_cli = app.using(TextSerializer())
```

### Write Comprehensive Examples
Include multiple display types and real-world patterns:
```python
@app.command(display="table")
def list_items(state):
    """Show all items in a formatted table."""
    return [{"id": i, "name": item} for i, item in enumerate(state.items)]

@app.command(display="tree")
def organize(state):
    """Display hierarchical organization."""
    return {"high": [...], "medium": [...], "low": [...]}
```

### Error Handling
Be explicit about edge cases:
```python
@app.command()
def get_item(state, id: int):
    if id < 0 or id >= len(state.items):
        return f"Error: Invalid ID {id}"
    return state.items[id]
```

## Custom Display Components

Register custom display handlers for complex layouts:
```python
@app.serializer.register("report")
def handle_report(data, meta):
    """Custom multi-section report display."""
    from replkit2.textkit import compose, box
    sections = []
    for title, section_data, opts in data:
        section_meta = CommandMeta(display=opts.get("display"), display_opts=opts)
        serialized = app.serializer.serialize(section_data, section_meta)
        sections.append(box(serialized, title=title))
    return compose(*sections, spacing=1)

@app.command(display="report")
def report(state):
    return [
        ("Stats", get_stats(state), {"display": "table"}),
        ("Items", get_items(state), {"display": "list"}),
        ("Tree", get_tree(state), {"display": "tree"})
    ]
```

## Common Patterns

### Progress Tracking
```python
@app.command(display="progress", show_percentage=True)
def completion(state):
    done = sum(1 for t in state.todos if t["done"])
    return {"value": done, "total": len(state.todos)}
```

### Multi-View Reports
```python
@app.command()
def report(state):
    return [
        ("Summary", state.get_summary(), {"display": "box"}),
        ("Tasks", state.todos, {"display": "table"}),
        ("Progress", {"value": 5, "total": 10}, {"display": "progress"})
    ]
```

### Interactive Features
Encourage rich interactions:
- Add multiple related commands
- Provide different views of same data
- Include statistics and summaries
- Support filtering and organization

## Testing Guidelines

Write general-purpose solutions:
- Handle edge cases (empty lists, invalid inputs)
- Don't hard-code test values
- Implement actual business logic
- Make commands reusable

## Running Applications

```python
if __name__ == "__main__":
    app.run(title="My Application Name")
```

## Output Quality

For impressive demos:
- Use multiple display types in one app
- Add thoughtful formatting options
- help() command is auto-generated
- Professional banner with app.run(title="...")
- Provide comprehensive functionality